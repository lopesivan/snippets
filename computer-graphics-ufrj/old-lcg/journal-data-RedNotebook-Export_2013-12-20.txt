

  Friday, 11/29/2013
  ==================


  Main
  ====


	OpenGL Book
	===========


		SGI
		===

O comitê que especifica/regula as especificações do OpenGL.


		OpenGL
		======

Conjunto de APIs padrões que especificam como as 'coisas' devem ser impementadas. 


		GLSL
		====

OpenGL Shading Language.


	Detalhes mais técnicos
	======================


		DirectX
		=======

Apenas da Microsoft. Keywords: direct3d, directplay, etc. Não é compatível nem com Mac nem com Linux nem com *BSD. Apenas o OpenGL é uma API aberta.


		WebGL
		=====

Para web browsers. 3D também.


		OpenGL Context
		==============

- Introduzido a partir do OpenGL 3.
- Major version, minor version, optional attributes.
 - Atributos. Combiná-los com OR ou pipe.
  - core ou compatibility profile (mutuamente exclusivas!)
  - forward compatible (nao contém features deprecated)
  - debug mode

A princípio, é controlado pela FreeGLUT (por exemplo).


		Compatibilidade
		===============

O OpenGL 3.3 é o último a suportar as features antigas, mantendo-se o máximo possível próximo do 4.0
A partir do 4.0, immediate mode não é mais usado. Exemplos:  glBegin, glEnd, glVertex3f, and glColor3f (<== não estão no core do OpenGL 4.0)


		Software Pipeline
		=================

- Application layer (ex.: Xorg, Xfree86 ?). Criar windows, threads, alocar memória etc. C: header files.
- Abstraction layer. Open GL API implementations. C: actual implementation.
- Device Driver (ex.: bumblebee da nvidia, catalyst da AMD). Invisível para o desenvolvedor. Comunicação software <-> hardware.
- Hardware (ex.: GeForce 9400 GT)


		Buffer
		======

- Conceito de Double Buffer
- Front Buffer vs Back Buffer


		Handle
		======

Uma espécie de ponteiro mais abstrato ainda. Faz referência a um widget (por exemplo), que pode ser uma janela, um pedaço de memória, etc. Note que ao  setar um handle, ele locka a memória; e ao soltá-lo (release), o SO já pode liberar os recursos aos quais ele se referia.  Digamos, um "void *". Ex.: WindowHandle. A memória real é escondida do API user. O sistema a trata de maneira transparente.


		ViewPort
		========

Conceito de ViewPort em uma scene maior. A partir da esquerda embaixo. Especifica width and height.


	Ambiente de Programação
	=======================

- gcc (essencial!)
- qt creator ou emacs como IDE/editor


		Bibliotecas
		===========

- FreeGLUT ==> window and context creation (possivelmente uma espécie de Xorg para as aplicações OpenGL)
- GLEW ==> para carregar extensões. Isso faz com que o programador não tenha que se preocupar muito com a dependência de plataformas para isso. (if windows, if linux, if possui_tal_feature ...)
- Devil ==> carregar imagens nos programas


  Observações
  ===========

- Não editar Makefile com o QT Creator. Ele não lida bem com tabs (em vez disso, as transforma em espaços!). O Gedit ou o Emacs são suficientemente bons para isso.


  Diário
  ======

- Ver:
 - /usr/include/GL/freeglut.h -> _std e _ext
 - /usr/include/GL/gl.h
 - /usr/include/GL/glew.h


  Referências
  ===========


	Main
	====

- http://openglbook.com/the-book/preface-what-is-opengl/
- http://konsnos.wordpress.com/2010/10/30/how-to-install-opengl-headers-in-linux-and-compile-your-source-files/
- http://homepage.cs.uiowa.edu/~cwyman/classes/fall04-22C151/handouts/glutBasics.pdf
- http://www.lighthouse3d.com
- http://www.opengl.org/discussion_boards/showthread.php/168717-I-dont-understand-what-glutPostRedisplay%28%29-does


	Misc
	====

- http://stackoverflow.com/questions/9580566/missing-separator-in-makefile
- http://pt.wikibooks.org/wiki/Programar_em_C/Makefiles
- http://en.wikipedia.org/wiki/Handle_%28computing%29
- http://stackoverflow.com/questions/902967/what-is-a-windows-handle
- http://stackoverflow.com/questions/8932912/whats-the-advantage-of-using-gluint-instead-of-unsigned-int
- http://www.lighthouse3d.com/tutorials/glut-tutorial/glutpostredisplay-vs-idle-func/
- http://stackoverflow.com/questions/15982470/which-is-better-starting-to-allegro-or-opengl
- http://stackoverflow.com/questions/15670580/whats-the-point-of-glutidlefunc-in-freeglut


  Dúvidas
  =======

- Immediate mode
- Software Pipeline. Confirmar se é isso mesmo.
- Stencil Buffers
- IdleFunction. OK. Ela é chamada sempre que o GLUT não tem mais eventos para processar.


  Ideias
  ======

- Mouse segurando (ferramenta pincel num canvas-like)
- Caixa se movendo com teclas (utilizar as bordas para nao deixar ela se mover)
- semáforo com ponte se abrindo


  Sugestão de programas para instalar
  ===================================

- gcolor2 <== determinar o rgb de qualquer tela; ver a cor de dado código
- xbindkeys e/ou ascii <== ver o código ASCII associado a dada tecla


  Thursday, 12/05/2013
  ====================


	SSH
	===

- Remove passphrase from SSH (google it) ==> ssh-keygen -p


  OpenGL
  ======

- http://blog.wolfire.com/2010/01/Why-you-should-use-OpenGL-and-not-DirectX


  Friday, 12/06/2013
  ==================


  Favorites
  =========

#reference

- http://www.khronos.org/files/opengl-quick-reference-card.pdf #32
- http://www.opengl.org/sdk/docs/reference_card/opengl40-quick-reference-card.pdf #40, 44
- http://www.opengl.org/registry/doc/glspec44.core.pdf

== OpenGL ==
- OpenGL ES ==> embedado
- abrir uma janela (ex.: freeGLUT)
- alocar um contexto openGL
- glew (probe extensions)
- open gl commands

- preocupa-se apenas em renderizar num framebuffer
- primitiva: ponto, segmento de linha, ou polígono (triângulo!)
- PONTO = VÉRTICE = FUNDAMENTAL!

- controle direto: transformação, luz, textura, e shading (<== operações)
- descreve como renderizar, mas não os objetos
- GL: server e programa = cliente (lembra do Xorg / X server)
- "network-transparent"
- um servidor pode ter vários contextos
- um cliente pode se conectar a qualquer um desses contextos
- comandos gl sem estar conectado a um contexto ==> comportamento não-definido

- default framebuffer -> window (apenas um)
- framebuffer object -> application (criar quantos quiser)

- nao existem comandos GL para lidar com o default framebuffer ==> isso é responsabilidade do window manager (exemplo: KWin, fluxbox) <== freeGLUT pode entrar aí!

- GLX specification -> opengl no X (GLX API) (Linux e Unix)
- khronos group que cuida de tudo

- extensões: GPU vendors podem implementar: custom APIs
- GL_HALF_FLOAT_NV (nv = nvidia)
- EXT ==> extensão de vários vendors (em comum)
ARB -> architecture review board do khronos group


		GLEW
		====

- instalar GLEW em ~/devel/
- no makefile, como flag: -I~/devel/glew-version/include


	Misc
	====

- http://www.bit-tech.net/news/bits/2013/07/23/opengl-opencl/1
- http://gamedev.stackexchange.com/questions/17687/differences-between-opengl-3-and-opengl-4
- http://www.conifersystems.com/whitepapers/gnu-make/
- http://www.opengl-tutorial.org/miscellaneous/faq/
- http://en.wikipedia.org/wiki/Homogeneous_coordinates # coordenadas homogêneas
- http://en.wikipedia.org/wiki/OpenGL
- http://en.wikipedia.org/wiki/Glue_code
- http://upload.wikimedia.org/wikipedia/commons/c/c2/Linux_Graphics_Stack_2013.svg
- glxgears program from mesa-utils package
- http://en.wikipedia.org/wiki/File:Gallium3D_vs_DRI_graphics_driver_model.svg
- http://en.wikipedia.org/wiki/File:Free_and_open-source-software_display_servers_and_UI_toolkits.svg


	Tags
	====

- reference


  Tuesday, 12/10/2013
  ===================


  Revisão de trigonometria
  ========================

- http://www.opengl-tutorial.org/miscellaneous/math-cheatsheet/

Vetor homogêneo: (x, y, z, w)
Vetor 3D associado: (x/w, y/w, z/w)

Para w=1, fica fácil de ver o vetor associado: POSIÇÃO.
w = 0 implica direção.

(x, y, z, w) é igual a
(2x, 2y, 2z, 2w)


	OpenGL / Rendering
	==================

- rasterização / rasterizador. Renderizar = transformar 3D em 2D
- conceito de clip space
- tesselation
- retained mode x immediate mode (o último é mais flexível e atualiza o display com mais frequência; o primeiro só atualiza a posição dos objetos, mas o display é atualizado mais tarde)


  Friday, 12/13/2013
  ==================


	Chapter 2 from OPENGL BOOK
	==========================

- callback function / helper function (HTDP)
- shader -> programa que roda na placa de vídeo
- no openGL: GLSL (shading language)
 - vertex shader (modifica os vértices)
 - fragment shader (modifica as cores)




